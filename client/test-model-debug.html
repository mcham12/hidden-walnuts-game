<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Debug Tool</title>
    <style>
        body { margin: 0; font-family: monospace; }
        #controls { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; }
        #log { position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; max-width: 400px; max-height: 600px; overflow-y: auto; }
        button { margin: 2px; padding: 5px; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        .info { color: #2196F3; }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Model Debug Tool</h3>
        <button onclick="testSquirrel()">Test Squirrel</button>
        <button onclick="testColobus()">Test Colobus</button>
        <button onclick="compareApproaches()">Compare Approaches</button>
        <button onclick="clearScene()">Clear Scene</button>
        <br><br>
        <div id="results"></div>
    </div>
    <div id="log"></div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let testResults = new Map();

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info';
            logDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            log('Scene initialized', 'success');
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function analyzeModel(model, name) {
            log(`=== Analyzing ${name} ===`, 'info');
            
            let meshCount = 0;
            let skinnedMeshCount = 0;
            let materialCount = 0;
            let visibleCount = 0;
            let invisibleCount = 0;
            let boundingBox = new THREE.Box3();
            
            model.traverse((child) => {
                const isMesh = child instanceof THREE.Mesh;
                const isSkinnedMesh = child instanceof THREE.SkinnedMesh;
                
                if (isMesh || isSkinnedMesh) {
                    if (isMesh) meshCount++;
                    if (isSkinnedMesh) skinnedMeshCount++;
                    
                    if (child.material) materialCount++;
                    if (child.visible) visibleCount++;
                    else invisibleCount++;
                    
                    boundingBox.expandByObject(child);
                }
            });
            
            const size = boundingBox.getSize(new THREE.Vector3());
            
            log(`  - Mesh count: ${meshCount}`, 'info');
            log(`  - SkinnedMesh count: ${skinnedMeshCount}`, 'info');
            log(`  - Material count: ${materialCount}`, 'info');
            log(`  - Visible objects: ${visibleCount}`, 'info');
            log(`  - Invisible objects: ${invisibleCount}`, 'info');
            log(`  - Bounding box size: (${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)})`, 'info');
            log(`  - Model visible: ${model.visible}`, 'info');
            log(`  - Model position: (${model.position.x.toFixed(2)}, ${model.position.y.toFixed(2)}, ${model.position.z.toFixed(2)})`, 'info');
            log(`  - Model scale: (${model.scale.x.toFixed(2)}, ${model.scale.y.toFixed(2)}, ${model.scale.z.toFixed(2)})`, 'info');
            
            return {
                meshCount,
                skinnedMeshCount,
                materialCount,
                visibleCount,
                invisibleCount,
                boundingBoxSize: size,
                modelVisible: model.visible
            };
        }

        async function loadModel(path, name) {
            try {
                log(`Loading ${name} from ${path}...`, 'info');
                
                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync(path);
                
                if (!gltf || !gltf.scene) {
                    throw new Error('Model loaded but scene is null');
                }
                
                const model = gltf.scene;
                log(`✅ ${name} loaded successfully`, 'success');
                
                return { model, gltf };
            } catch (error) {
                log(`❌ Failed to load ${name}: ${error.message}`, 'error');
                return null;
            }
        }

        async function testSquirrel() {
            log('=== Testing Squirrel Model ===', 'info');
            
            const result = await loadModel('/assets/models/environment/squirrel.glb', 'Squirrel');
            if (!result) return;
            
            const { model } = result;
            
            // Test local approach (no cloning)
            const localModel = model;
            localModel.scale.set(0.3, 0.3, 0.3);
            localModel.position.set(-3, 0.1, 0);
            localModel.castShadow = true;
            localModel.receiveShadow = true;
            
            scene.add(localModel);
            
            const analysis = analyzeModel(localModel, 'Squirrel (Local)');
            testResults.set('squirrel-local', analysis);
            
            log('✅ Squirrel test completed', 'success');
        }

        async function testColobus() {
            log('=== Testing Colobus Model ===', 'info');
            
            const result = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'Colobus');
            if (!result) return;
            
            const { model } = result;
            
            // Test local approach (no cloning)
            const localModel = model;
            localModel.scale.set(0.3, 0.3, 0.3);
            localModel.position.set(0, 0.1, 0);
            localModel.castShadow = true;
            localModel.receiveShadow = true;
            
            scene.add(localModel);
            
            const analysis = analyzeModel(localModel, 'Colobus (Local)');
            testResults.set('colobus-local', analysis);
            
            log('✅ Colobus test completed', 'success');
        }

        async function compareApproaches() {
            log('=== Comparing Local vs Remote Approaches ===', 'info');
            
            // Clear scene
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            // Re-add lighting and ground
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Test 1: Local approach (no cloning)
            const localResult = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'Colobus');
            if (localResult) {
                const localModel = localResult.model;
                localModel.scale.set(0.3, 0.3, 0.3);
                localModel.position.set(-3, 0.1, 0);
                localModel.castShadow = true;
                localModel.receiveShadow = true;
                scene.add(localModel);
                
                const localAnalysis = analyzeModel(localModel, 'Colobus (Local - No Cloning)');
                testResults.set('colobus-local', localAnalysis);
            }
            
            // Test 2: Remote approach (with cloning)
            const remoteResult = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'Colobus');
            if (remoteResult) {
                const remoteModel = remoteResult.model.clone();
                remoteModel.scale.set(0.3, 0.3, 0.3);
                
                // Apply recursive scaling (like remote player does)
                remoteModel.traverse((child) => {
                    if (child !== remoteModel) {
                        child.scale.set(0.3, 0.3, 0.3);
                    }
                });
                
                remoteModel.position.set(3, 0.1, 0);
                remoteModel.castShadow = true;
                remoteModel.receiveShadow = true;
                
                // Apply material modifications (like remote player does)
                remoteModel.traverse((child) => {
                    if ((child instanceof THREE.Mesh || child instanceof THREE.SkinnedMesh) && child.material) {
                        const material = child.material.clone();
                        if (material instanceof THREE.MeshStandardMaterial) {
                            material.color.multiplyScalar(0.8);
                        }
                        child.material = material;
                    }
                });
                
                scene.add(remoteModel);
                
                const remoteAnalysis = analyzeModel(remoteModel, 'Colobus (Remote - With Cloning)');
                testResults.set('colobus-remote', remoteAnalysis);
            }
            
            // Compare results
            const local = testResults.get('colobus-local');
            const remote = testResults.get('colobus-remote');
            
            if (local && remote) {
                log('=== Comparison Results ===', 'info');
                log(`Mesh count - Local: ${local.meshCount}, Remote: ${remote.meshCount}`, 'info');
                log(`SkinnedMesh count - Local: ${local.skinnedMeshCount}, Remote: ${remote.skinnedMeshCount}`, 'info');
                log(`Visible objects - Local: ${local.visibleCount}, Remote: ${remote.visibleCount}`, 'info');
                log(`Invisible objects - Local: ${local.invisibleCount}, Remote: ${remote.invisibleCount}`, 'info');
                
                if (local.visibleCount !== remote.visibleCount) {
                    log('⚠️ WARNING: Different visible object counts!', 'warning');
                }
                if (local.skinnedMeshCount !== remote.skinnedMeshCount) {
                    log('⚠️ WARNING: Different SkinnedMesh counts!', 'warning');
                }
            }
            
            log('✅ Comparison completed', 'success');
        }

        function clearScene() {
            while(scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            testResults.clear();
            log('Scene cleared', 'info');
        }

        // Make functions globally available
        window.testSquirrel = testSquirrel;
        window.testColobus = testColobus;
        window.compareApproaches = compareApproaches;
        window.clearScene = clearScene;

        init();
    </script>
</body>
</html> 