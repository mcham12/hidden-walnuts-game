<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Player Creation Test</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.8); 
            color: white; 
            padding: 10px; 
            border-radius: 5px;
            max-width: 500px;
            font-size: 12px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover { background: #45a049; }
        .error { color: #ff6b6b; }
        .success { color: #51cf66; }
        .warning { color: #ffd43b; }
        .info { color: #74c0fc; }
    </style>
</head>
<body>
    <div id="info">Initializing test environment...</div>
    <div id="controls">
        <button onclick="testLocalApproach()">Test Local Approach</button>
        <button onclick="testRemoteApproach()">Test Remote Approach</button>
        <button onclick="testHybridApproach()">Test Hybrid Approach</button>
        <button onclick="testSquirrelModel()">Test Squirrel Model</button>
        <button onclick="clearScene()">Clear Scene</button>
        <button onclick="compareResults()">Compare Results</button>
    </div>

    <script type="module">
        // Import Three.js from the same source as the main app
        import * as THREE from '/node_modules/three/build/three.module.js';
        import { GLTFLoader } from '/node_modules/three/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from '/node_modules/three/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let testResults = new Map();
        let loadedModels = new Map();

        function log(message, type = 'info') {
            const infoDiv = document.getElementById('info');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'warning' ? 'warning' : 'info';
            infoDiv.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            console.log(`[${timestamp}] ${message}`);
        }

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            log('Test environment initialized', 'success');
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function analyzeModel(model, name) {
            log(`=== Analyzing ${name} ===`, 'info');
            
            // Basic properties
            log(`Type: ${model.type}`, 'info');
            log(`Children count: ${model.children.length}`, 'info');
            log(`Visible: ${model.visible}`, 'info');
            log(`Position: (${model.position.x.toFixed(2)}, ${model.position.y.toFixed(2)}, ${model.position.z.toFixed(2)})`, 'info');
            log(`Scale: (${model.scale.x.toFixed(2)}, ${model.scale.y.toFixed(2)}, ${model.scale.z.toFixed(2)})`, 'info');

            // Mesh analysis
            let meshCount = 0;
            let skinnedMeshCount = 0;
            let materialCount = 0;
            let visibleMeshCount = 0;
            let boundingBox = new THREE.Box3();
            let hasBoundingBox = false;

            model.traverse((child) => {
                const isMesh = child instanceof THREE.Mesh || child.type === 'Mesh';
                const isSkinnedMesh = child instanceof THREE.SkinnedMesh || child.type === 'SkinnedMesh';
                
                if (isMesh || isSkinnedMesh) {
                    if (isSkinnedMesh) {
                        skinnedMeshCount++;
                        log(`    -> SKINNED MESH: geometry=${!!child.geometry}, material=${!!child.material}`, 'info');
                    } else {
                        meshCount++;
                        log(`    -> MESH: geometry=${!!child.geometry}, material=${!!child.material}`, 'info');
                    }
                    
                    if (child.material) {
                        materialCount++;
                    }
                    if (child.visible) {
                        visibleMeshCount++;
                    }
                    
                    // Calculate bounding box
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        if (child.geometry.boundingBox) {
                            boundingBox.expandByObject(child);
                            hasBoundingBox = true;
                        }
                    }
                }
            });

            log(`Mesh count: ${meshCount}`, 'info');
            log(`SkinnedMesh count: ${skinnedMeshCount}`, 'info');
            log(`Total renderable objects: ${meshCount + skinnedMeshCount}`, 'info');
            log(`Visible mesh count: ${visibleMeshCount}`, 'info');
            log(`Material count: ${materialCount}`, 'info');

            if (hasBoundingBox) {
                const size = boundingBox.getSize(new THREE.Vector3());
                const center = boundingBox.getCenter(new THREE.Vector3());
                log(`Bounding box size: (${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)})`, 'info');
                log(`Bounding box center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`, 'info');
            }

            return {
                meshCount: meshCount + skinnedMeshCount, // Total renderable objects
                visibleMeshCount,
                materialCount,
                boundingBox: hasBoundingBox ? boundingBox : null,
                visible: model.visible,
                inScene: scene.children.includes(model)
            };
        }

        async function loadModel(path, name) {
            try {
                log(`Loading ${name} from ${path}...`, 'info');
                
                const response = await fetch(path);
                if (!response.ok) {
                    throw new Error(`Asset not found: ${path} (${response.status})`);
                }
                log(`Asset available: ${path}`, 'success');

                const loader = new GLTFLoader();
                const gltf = await loader.loadAsync(path);
                
                if (!gltf || !gltf.scene) {
                    throw new Error('Model loaded but scene is null');
                }

                const model = gltf.scene;
                log(`Model loaded successfully: ${name}`, 'success');
                
                // Deep debugging of model structure
                log(`=== Deep Model Analysis for ${name} ===`, 'info');
                log(`GLTF scene type: ${model.type}`, 'info');
                log(`GLTF scene children: ${model.children.length}`, 'info');
                
                // Analyze the GLTF structure
                if (gltf.parser) {
                    log(`GLTF has parser: ${!!gltf.parser}`, 'info');
                }
                
                // Traverse and log the entire structure
                let totalObjects = 0;
                let totalMeshes = 0;
                let totalSkinnedMeshes = 0;
                let totalGroups = 0;
                let totalBones = 0;
                
                model.traverse((child) => {
                    totalObjects++;
                    log(`  Object ${totalObjects}: type=${child.type}, name=${child.name || 'unnamed'}`, 'info');
                    
                    // Debug THREE object and instanceof checks
                    log(`    -> THREE.Mesh constructor: ${THREE.Mesh ? 'exists' : 'missing'}`, 'info');
                    log(`    -> THREE.SkinnedMesh constructor: ${THREE.SkinnedMesh ? 'exists' : 'missing'}`, 'info');
                    log(`    -> child.constructor: ${child.constructor.name}`, 'info');
                    
                    const isMesh = child instanceof THREE.Mesh;
                    const isSkinnedMesh = child instanceof THREE.SkinnedMesh;
                    log(`    -> instanceof THREE.Mesh: ${isMesh}`, 'info');
                    log(`    -> instanceof THREE.SkinnedMesh: ${isSkinnedMesh}`, 'info');
                    
                    // Alternative check using type property
                    const isMeshByType = child.type === 'Mesh';
                    const isSkinnedMeshByType = child.type === 'SkinnedMesh';
                    log(`    -> type === 'Mesh': ${isMeshByType}`, 'info');
                    log(`    -> type === 'SkinnedMesh': ${isSkinnedMeshByType}`, 'info');
                    
                    if (isMesh || isMeshByType) {
                        totalMeshes++;
                        log(`    -> MESH: geometry=${!!child.geometry}, material=${!!child.material}`, 'info');
                        if (child.geometry) {
                            log(`    -> Geometry: vertices=${child.geometry.attributes.position?.count || 0}`, 'info');
                        }
                    } else if (isSkinnedMesh || isSkinnedMeshByType) {
                        totalSkinnedMeshes++;
                        log(`    -> SKINNED MESH: geometry=${!!child.geometry}, material=${!!child.material}`, 'info');
                        if (child.geometry) {
                            log(`    -> Geometry: vertices=${child.geometry.attributes.position?.count || 0}`, 'info');
                        }
                    } else if (child instanceof THREE.Group || child.type === 'Group') {
                        totalGroups++;
                        log(`    -> GROUP: children=${child.children.length}`, 'info');
                    } else if (child instanceof THREE.Bone || child.type === 'Bone') {
                        totalBones++;
                        log(`    -> BONE`, 'info');
                    }
                });
                
                log(`Total objects: ${totalObjects}`, 'info');
                log(`Total meshes: ${totalMeshes}`, 'info');
                log(`Total skinned meshes: ${totalSkinnedMeshes}`, 'info');
                log(`Total renderable objects: ${totalMeshes + totalSkinnedMeshes}`, 'info');
                log(`Total groups: ${totalGroups}`, 'info');
                log(`Total bones: ${totalBones}`, 'info');
                
                // Check if there are any animations
                if (gltf.animations && gltf.animations.length > 0) {
                    log(`Animations: ${gltf.animations.length}`, 'info');
                }
                
                loadedModels.set(name, model);
                return model;

            } catch (error) {
                log(`❌ Failed to load ${name}: ${error.message}`, 'error');
                console.error(`Error loading ${name}:`, error);
                return null;
            }
        }

        // Test 1: Local Player Approach (No Cloning)
        window.testLocalApproach = async () => {
            log('=== Testing Local Player Approach (No Cloning) ===', 'info');
            
            const model = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'colobus');
            if (!model) return;

            // Simulate local player creation (no cloning)
            const localModel = model; // No cloning
            localModel.scale.set(0.3, 0.3, 0.3);
            localModel.position.set(-3, 0.1, 0);
            localModel.castShadow = true;
            localModel.receiveShadow = true;

            // Apply shadow settings to children
            localModel.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(localModel);
            loadedModels.set('local-approach', localModel);

            const analysis = analyzeModel(localModel, 'Local Approach');
            testResults.set('local', analysis);

            log('✅ Local approach test completed', 'success');
        };

        // Test 2: Remote Player Approach (With Cloning)
        window.testRemoteApproach = async () => {
            log('=== Testing Remote Player Approach (With Cloning) ===', 'info');
            
            const model = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'colobus');
            if (!model) return;

            // Simulate remote player creation (with cloning)
            const remoteModel = model.clone(); // Cloning happens here
            remoteModel.scale.set(0.3, 0.3, 0.3);
            
            // Apply scale to children (like remote player does)
            remoteModel.traverse((child) => {
                if (child !== remoteModel) {
                    child.scale.set(0.3, 0.3, 0.3);
                }
            });
            
            remoteModel.position.set(3, 0.1, 0);
            remoteModel.castShadow = true;
            remoteModel.receiveShadow = true;

            // Apply shadow settings to children
            remoteModel.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(remoteModel);
            loadedModels.set('remote-approach', remoteModel);

            const analysis = analyzeModel(remoteModel, 'Remote Approach');
            testResults.set('remote', analysis);

            log('✅ Remote approach test completed', 'success');
        };

        // Test 3: Hybrid Approach (Minimal Cloning)
        window.testHybridApproach = async () => {
            log('=== Testing Hybrid Approach (Minimal Cloning) ===', 'info');
            
            const model = await loadModel('/assets/models/characters/Colobus_LOD0.glb', 'colobus');
            if (!model) return;

            // Simulate hybrid approach (clone but minimal processing)
            const hybridModel = model.clone(); // Cloning but no extra scaling
            hybridModel.scale.set(0.3, 0.3, 0.3);
            hybridModel.position.set(0, 0.1, 3);
            hybridModel.castShadow = true;
            hybridModel.receiveShadow = true;

            // Apply shadow settings to children
            hybridModel.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(hybridModel);
            loadedModels.set('hybrid-approach', hybridModel);

            const analysis = analyzeModel(hybridModel, 'Hybrid Approach');
            testResults.set('hybrid', analysis);

            log('✅ Hybrid approach test completed', 'success');
        };

        // Test 4: Squirrel Model Comparison
        window.testSquirrelModel = async () => {
            log('=== Testing Squirrel Model for Comparison ===', 'info');
            
            const model = await loadModel('/assets/models/environment/squirrel.glb', 'squirrel');
            if (!model) return;

            // Test squirrel with same approach as local
            const squirrelModel = model; // No cloning
            squirrelModel.scale.set(0.3, 0.3, 0.3);
            squirrelModel.position.set(0, 0.1, -3);
            squirrelModel.castShadow = true;
            squirrelModel.receiveShadow = true;

            // Apply shadow settings to children
            squirrelModel.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            scene.add(squirrelModel);
            loadedModels.set('squirrel-test', squirrelModel);

            const analysis = analyzeModel(squirrelModel, 'Squirrel Model');
            testResults.set('squirrel', analysis);

            log('✅ Squirrel model test completed', 'success');
        };

        window.clearScene = () => {
            loadedModels.forEach((model, name) => {
                if (name !== 'colobus') { // Keep base model
                    scene.remove(model);
                    log(`Removed ${name} from scene`, 'info');
                }
            });
            loadedModels.clear();
            testResults.clear();
            log('Scene cleared', 'success');
        };

        window.compareResults = () => {
            log('=== COMPARISON RESULTS ===', 'info');
            
            if (testResults.size === 0) {
                log('No test results to compare. Run tests first.', 'warning');
                return;
            }

            const approaches = ['local', 'remote', 'hybrid'];
            approaches.forEach(approach => {
                const result = testResults.get(approach);
                if (result) {
                    log(`${approach.toUpperCase()}:`, 'info');
                    log(`  - Meshes: ${result.meshCount}`, 'info');
                    log(`  - Visible meshes: ${result.visibleMeshCount}`, 'info');
                    log(`  - Materials: ${result.materialCount}`, 'info');
                    log(`  - Visible: ${result.visible}`, 'info');
                    log(`  - In scene: ${result.inScene}`, 'info');
                }
            });

            // Identify differences
            const local = testResults.get('local');
            const remote = testResults.get('remote');
            
            if (local && remote) {
                if (local.visibleMeshCount !== remote.visibleMeshCount) {
                    log('⚠️ DIFFERENCE: Visible mesh count differs between approaches!', 'warning');
                    log(`  Local: ${local.visibleMeshCount}, Remote: ${remote.visibleMeshCount}`, 'warning');
                }
                
                if (local.meshCount !== remote.meshCount) {
                    log('⚠️ DIFFERENCE: Total mesh count differs between approaches!', 'warning');
                    log(`  Local: ${local.meshCount}, Remote: ${remote.meshCount}`, 'warning');
                }
            }
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        init();
        log('Remote player creation test ready. Use buttons to test different approaches.', 'success');
    </script>
</body>
</html> 